# Project overview

You are enhancing this solution bybuilding a table and upload button that will have an interface akin to a SharePoint list or OneDrive. Multiple documents should be able to be uploaded to the table at a time. As each pdf document is being uploaded it should be added to the table. Each document should have it's own row in the table. The table should be able to be sorted by a column. The table should be able to be filtered by a column. The table should be able to be searched by a column. The table should be able to be paginated. The table will have the following columns:

1. Document Name
2. Document Size
3. Document Classification (extracted from the classifyDocument function)

You will be using NextJS 14, shadcn, Fluent UI V9 React Components, and TailwindCSS.

# Core functionalities

1. Upload multiple documents to the table

- Allow a dropzone for users to upload documents
- Store the documents in a database
- Use Firebase Storage to store the documents
- As each document is uploaded, add it to the table, with the following columns:
- Document Name
- Document Classification
- Document Size

2. Sort the table by a column
3. Filter the table by a column
4. Search the table by a column
5. Paginate the table

# Doc

**##Documentation of how to use Fluent UI in NextJS >13**

```
Next.js@>=13 appDir router
For basic instructions on getting Next.js set up, see Getting Started.

Get a basic next.js setup running, rendering a page from the app folder, as guided by the tutorial.
Add the Fluent UI dependencies: @fluentui/react-components.
Add the SWC plugin to add the client directive for our library: fluentui-next-appdir-directive. See the repo for more information
# Using Yarn
yarn add @fluentui/react-components fluentui-next-appdir-directive

# Using NPM
npm install @fluentui/react-components fluentui-next-appdir-directive
Copy
Setting up Fluent UI
Create a providers.tsx file under your app folder with the following content:
'use client';

import * as React from 'react';
import {
  FluentProvider,
  teamsDarkTheme,
  SSRProvider,
  RendererProvider,
  createDOMRenderer,
  renderToStyleElements,
} from '@fluentui/react-components';
import { useServerInsertedHTML } from 'next/navigation';

export function Providers({ children }: { children: React.ReactNode }) {
  const [renderer] = React.useState(() => createDOMRenderer());
  const didRenderRef = React.useRef(false);

  useServerInsertedHTML(() => {
    if (didRenderRef.current) {
      return;
    }
    didRenderRef.current = true;
    return <>{renderToStyleElements(renderer)}</>;
  });

  return (
    <RendererProvider renderer={renderer}>
      <SSRProvider>
        <FluentProvider theme={teamsDarkTheme}>{children}</FluentProvider>
      </SSRProvider>
    </RendererProvider>
  );
}
Copy
Modify the layout.tsx file under your app folder to add our providers:
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import './globals.css';

// ðŸ‘‡ import the providers
import { Providers } from './providers';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: 'Create Next App',
  description: 'Generated by create next app',
};

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body className={inter.className}>
        {/* ðŸ‘‡ Apply them to children */}
        <Providers>{children}</Providers>
      </body>
    </html>
  );
}
Copy
Add fluentui-next-appdir-directive plugin with the paths for @griffel and @fluentui:
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    swcPlugins: [['fluentui-next-appdir-directive', { paths: ['@griffel', '@fluentui'] }]],
  },
};

module.exports = nextConfig;
Copy
Finally add your code to the page.tsx file in your app folder:
import * as React from 'react';
import { Button } from '@fluentui/react-components';

export default function Home() {
  return <Button>Hello everyone</Button>;
}
```

**##SWC Plugin Repository**

````
================================================
File: /README.md
================================================
# [@Fluent UI v9](https://react.fluentui.dev/) NextJS AppDir router support plugin

This plugin allows the use of `@fluentui/react-components` and `@griffel` in the new NextJS@13+ appDir router. The goal of this plugin is to add the `"use client";` directive to all files in `@fluentui/react-components` and `@griffel`, but note it's not limited to these libraries.

### Installation

```sh
# yarn
yarn add fluentui-next-appdir-directive

# npm
npm i fluentui-next-appdir-directive
````

### Configuration for `@fluentui/react-components` and `@griffel`:

```js
// next.config.js

/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    swcPlugins: [
      ["fluentui-next-appdir-directive",{
         paths: [
          "@griffel",
          "@fluentui"
          // ðŸ‘‡ you can add another dependency that needs the directive
          "your dependency name"
        ]
      }],
    ],
  },
};

module.exports = nextConfig;
```

### Configuration for usage outside of NextJS

```json
// .swcrc
{
  "jsc": {
    "experimental": {
      "plugins": [
        ["fluentui-next-appdir-directive", {
          "paths": [
            "@griffel",
            "@fluentui"
             // ðŸ‘‡ you can add another dependency that needs the directive
             "your dependency name"
          ]
        }]
      ]
    }
  }
}
```

> Note: strings inside paths should only contain the scope/package name, in our case @fluentui/react-components -> @fluentui

### My modules are getting ignored and gives me an error in NextJS 14.1.2+:

```js
// next.config.js

/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    swcPlugins: [
      ["fluentui-next-appdir-directive",{
         paths: [
          "@griffel",
          "@fluentui"
          // ðŸ‘‡ you can add another dependency that needs the directive
          "your dependency name"
        ]
      }],
    ],
  },
  // ðŸ‘‡ packages that need the directive
  transpilePackages: ["@fluentui/react-components"]
};

module.exports = nextConfig;
```

### Version compat

- For versions `< 14.1.2` please use `0.1.5` otherwise there wil be issues with the swc_core version causing rust to panic.
- For versions `>= 14.1.2` please use `0.1.7` for the same reason as above, `0.1.7` introduced version `0.90.*` of swc_core which makes it compatible with the versions used in `<= 14.1.2`.
- For versions `>= 15.0.0` please use `0.2.0` due to a necessary swc_core bump.

### My packages aren't getting tree-shaken

This is a known issue of using this directive, one way to get around it is to optimizePackage/modularizeImports imports:

- https://nextjs.org/docs/app/api-reference/next-config-js/optimizePackageImports
- https://nextjs.org/docs/architecture/nextjs-compiler#modularize-imports

================================================
File: /transform/tests/fixture/all/simple/input.js
================================================
export {};
console.log('This should add "use client" at the top');

================================================
File: /transform/tests/fixture/all/simple/output.js
================================================
"use client";
export {};
console.log('This should add "use client" at the top');

================================================
File: /transform/tests/fixture.rs
================================================
use std::path::PathBuf;

use directive_transform::TransformVisitor;
use swc_core::ecma::{
parser::{EsSyntax, Syntax},
transforms::testing::{test_fixture, FixtureTestConfig},
visit::visit_mut_pass,
};

// use std::path::{Path, PathBuf};

// use directive_transform::TransformVisitor;
// use swc_core::{
// common::{sync::Lrc, SourceMap},
// ecma::{
// ast::{EsVersion, Pass, Program},
// codegen::{text_writer, Emitter},
// parser::{lexer::Lexer, EsSyntax, Parser, StringInput, Syntax},
// visit::visit_mut_pass,
// },
// };
// use testing::{run_test2, NormalizedOutput};

// pub fn print(cm: Lrc<SourceMap>, program: &Program) -> String {
// let mut buf = Vec::new();
// {
// let mut emitter = Emitter {
// cfg: Default::default(),
// cm: cm.clone(),
// wr: Box::new(text_writer::JsWriter::new(cm, "\n", &mut buf, None)),
// comments: None,
// };

// emitter.emit_program(program).unwrap();
// }

// let s = String::from_utf8_lossy(&buf);
// s.to_string()
// }

// fn run<F, P>(syntax: Syntax, input: &Path, op: F)
// where
// F: FnOnce() -> P,
// P: Pass,
// {
// let dir = input.parent().unwrap();
// let output = dir.join(format!(
// "output.{}",
// input.extension().unwrap().to_string_lossy(),
// ));

// run_test2(false, |cm, handler| {
// let fm = cm.load_file(input).unwrap();

// let lexer = Lexer::new(syntax, EsVersion::latest(), StringInput::from(&\*fm), None);
// let mut parser = Parser::new_from(lexer);

// let program = parser
// .parse_program()
// .map_err(|err| err.into_diagnostic(&handler).emit())?;

// let mut folder = op();

// let program = program.apply(&mut folder);

// let actual = print(cm, &program);

// let actual = NormalizedOutput::from(actual);

// println!("AAAAAActual {:?}", actual);

// actual.compare_to_file(&output).unwrap();

// Ok(())
// })
// .unwrap();
// }

#[testing::fixture("tests/fixture/**/input.js")]
fn fixture(input: PathBuf) {
// run(
// Syntax::Es(EsSyntax {
// ..Default::default()
// }),
// &input,
// || {
// visit_mut_pass(TransformVisitor {
// file_path: "path_to_look_for/current_path".into(),
// paths: ["path_to_look_for".into()].to_vec(),
// })
// },
// );

    let output = input.parent().unwrap().join("output.js");
    test_fixture(
        Syntax::Es(EsSyntax {
            jsx: true,
            ..Default::default()
        }),
        &|_t| {
            visit_mut_pass(TransformVisitor {
                file_path: "test".into(),
                paths: ["test".into()].to_vec(),
            })
        },
        &input,
        &output,
        FixtureTestConfig {
            ..Default::default()
        },
    );

    // test_fixture(
    //     Syntax::Es(EsSyntax {
    //         ..Default::default()
    //     }),
    //     &|tester| transformer(tester),
    //     &input,
    //     &output,
    //     Default::default(),
    // );

    // test_fixture(Syntax::Es(EsSyntax {
    //     js: input.to_string_lossy().ends_with(".js"),
    //     ..Default::default()
    // }), true, TransformVisitor, &input, &output);

    // test_fixture(Syntax::Es(EsConfig {
    //     js: input.to_string_lossy().ends_with(".js"),
    //     ..Default::default()
    // }),
    // &|t| (tr(), properties(t, true))
    // ),
    // &input,
    // &output

}

================================================
File: /transform/Cargo.toml
================================================
[package]
name = "directive_transform"
version = "0.1.0"
edition = "2021"
authors = ["Esteban Munoz Facusse"]

[profile.release]
lto = true

[dependencies]
serde = "1"
swc_core = { version = "5.0.4", features = [
"common",
"ecma_ast",
"ecma_codegen",
"ecma_utils",
"ecma_visit",
] }

[dev-dependencies]
serde_json = "1"
swc_core = { version = "5.0.4", features = [
"testing_transform",
"ecma_parser",
"ecma_transforms_react",
] }
testing = "4.0.0"

# .cargo/config defines few alias to build plugin.

# cargo build-wasi generates wasm-wasi32 binary

# cargo build-wasm32 generates wasm32-unknown-unknown binary.

================================================
File: /transform/src/lib.rs
================================================
use serde::Deserialize;
use swc_core::{
common::DUMMY_SP,
ecma::{
ast::{Expr, ExprStmt, Lit, Module, ModuleItem, Stmt, Str},
visit::VisitMut,
},
};

#[derive(Debug, Default, Clone, Deserialize)] #[serde(rename_all = "camelCase", deny_unknown_fields)]
pub struct Config { #[serde(default)]
pub paths: Vec<String>,
}

pub struct TransformVisitor {
pub file_path: String,
pub paths: Vec<String>,
}

impl VisitMut for TransformVisitor {
fn visit_mut_module(&mut self, n: &mut Module) {
for path in &self.paths {
if self.file_path.contains(path) {
// Creating line for "use client" directive
let directive = ModuleItem::Stmt(Stmt::Expr(ExprStmt {
span: DUMMY_SP,
expr: Box::new(Expr::Lit(Lit::Str(Str {
span: DUMMY_SP,
value: "use client".into(),
raw: None,
}))),
}));
n.body.insert(0, directive.clone());
}
}
}
}

================================================
File: /Cargo.toml
================================================
[package]
name = "fluentui-next-appdir-directive"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[profile.release]
lto = false

[workspace]
members = ["transform"]

[dependencies]
serde = "1"
serde_json = "1.0.100"
swc_core = { version = "5.0.4", features = ["ecma_plugin_transform", "ecma_parser"] }
directive_transform = { path = "./transform" }

# .cargo/config defines few alias to build plugin.

# cargo build-wasi generates wasm-wasi32 binary

# cargo build-wasm32 generates wasm32-unknown-unknown binary.

================================================
File: /package.json
================================================
{
"name": "fluentui-next-appdir-directive",
"version": "0.2.0",
"description": "SWC plugin to add \"use client\" directive to Fluent UI, Griffel, and any other packages.",
"author": "Esteban Munoz Facusse",
"license": "ISC",
"keywords": [
"swc-plugin"
],
"main": "target/wasm32-wasi/release/fluentui_next_appdir_directive.wasm",
"scripts": {
"build-wasi": "cargo build --target wasm32-wasi",
"build-wasm32": "cargo build --target wasm32-unknown-unknown",
"prepare": "yarn build-wasi --release",
"prepare:release": "yarn build-wasi --release && cp target/wasm32-wasi/release/fluentui_next_appdir_directive.wasm ./fluentui_next_appdir_directive.wasm",
"test": "cargo test -p directive_transform"
},
"files": [
"fluentui_next_appdir_directive.wasm"
],
"preferUnplugged": true
}

================================================
File: /src/lib.rs
================================================
use directive_transform::{Config, TransformVisitor};
use swc_core::{
ecma:: {
ast::Program,
visit::VisitMutWith
},
plugin::{plugin_transform, proxies::TransformPluginProgramMetadata, metadata::TransformPluginMetadataContextKind},
};

#[plugin_transform]
pub fn process_transform(mut program: Program, data: TransformPluginProgramMetadata) -> Program {
let config_json = &data.get_transform_plugin_config()
.expect("failed to get plugin data, paths must be provided");
let config = serde_json::from_str::<Config>(config_json).expect("invalid config for fluentui-next-appdir-directive swc plugin");

    let file_path = match data.get_context(&TransformPluginMetadataContextKind::Filename) {
        Some(s) => s,
        None => String::from("")
    };

    program.visit_mut_with(&mut TransformVisitor {file_path: file_path, paths: config.paths});
    program

}

```

**## Example of how to generate a Microsoft Graph client and call a SharePoint site list**
```

import type { NextApiRequest, NextApiResponse } from 'next';
import axios from 'axios';

interface GraphResponse {
value: {
id: string;
fields: {
Title: string;
[key: string]: any; // To handle additional fields
};
}[];
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
try {
// Fetch an access token
const tokenResponse = await axios.post('https://login.microsoftonline.com/<tenant-id>/oauth2/v2.0/token', new URLSearchParams({
grant_type: 'client_credentials',
client_id: process.env.CLIENT_ID || '',
client_secret: process.env.CLIENT_SECRET || '',
scope: 'https://graph.microsoft.com/.default',
}).toString(), {
headers: {
'Content-Type': 'application/x-www-form-urlencoded',
},
});

    const accessToken = tokenResponse.data.access_token;

    // Fetch data from the SharePoint list
    const listResponse = await axios.get<GraphResponse>(
      'https://graph.microsoft.com/v1.0/sites/<site-id>/lists/<list-id>/items',
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      }
    );

    res.status(200).json(listResponse.data.value);

} catch (error) {
console.error(error);
res.status(500).json({ error: 'Failed to fetch SharePoint list' });
}
}

```

**## Example of how to use Fluent UI Table component**
```

import \* as React from "react";
import {
FolderRegular,
EditRegular,
OpenRegular,
DocumentRegular,
PeopleRegular,
DocumentPdfRegular,
VideoRegular,
} from "@fluentui/react-icons";
import {
PresenceBadgeStatus,
Avatar,
TableBody,
TableCell,
TableRow,
Table,
TableHeader,
TableHeaderCell,
useTableFeatures,
TableColumnDefinition,
TableColumnId,
useTableSort,
TableCellLayout,
createTableColumn,
} from "@fluentui/react-components";

type FileCell = {
label: string;
icon: JSX.Element;
};

type LastUpdatedCell = {
label: string;
timestamp: number;
};

type LastUpdateCell = {
label: string;
icon: JSX.Element;
};

type AuthorCell = {
label: string;
status: PresenceBadgeStatus;
};

type Item = {
file: FileCell;
author: AuthorCell;
lastUpdated: LastUpdatedCell;
lastUpdate: LastUpdateCell;
};

const items: Item[] = [
{
file: { label: "Meeting notes", icon: <DocumentRegular /> },
author: { label: "Max Mustermann", status: "available" },
lastUpdated: { label: "7h ago", timestamp: 3 },
lastUpdate: {
label: "You edited this",
icon: <EditRegular />,
},
},
{
file: { label: "Thursday presentation", icon: <FolderRegular /> },
author: { label: "Erika Mustermann", status: "busy" },
lastUpdated: { label: "Yesterday at 1:45 PM", timestamp: 2 },
lastUpdate: {
label: "You recently opened this",
icon: <OpenRegular />,
},
},
{
file: { label: "Training recording", icon: <VideoRegular /> },
author: { label: "John Doe", status: "away" },
lastUpdated: { label: "Yesterday at 1:45 PM", timestamp: 2 },
lastUpdate: {
label: "You recently opened this",
icon: <OpenRegular />,
},
},
{
file: { label: "Purchase order", icon: <DocumentPdfRegular /> },
author: { label: "Jane Doe", status: "offline" },
lastUpdated: { label: "Tue at 9:30 AM", timestamp: 1 },
lastUpdate: {
label: "You shared this in a Teams chat",
icon: <PeopleRegular />,
},
},
];

const columns: TableColumnDefinition<Item>[] = [
createTableColumn<Item>({
columnId: "file",
compare: (a, b) => {
return a.file.label.localeCompare(b.file.label);
},
}),
createTableColumn<Item>({
columnId: "author",
compare: (a, b) => {
return a.author.label.localeCompare(b.author.label);
},
}),
createTableColumn<Item>({
columnId: "lastUpdated",
compare: (a, b) => {
return a.lastUpdated.timestamp - b.lastUpdated.timestamp;
},
}),
createTableColumn<Item>({
columnId: "lastUpdate",
compare: (a, b) => {
return a.lastUpdate.label.localeCompare(b.lastUpdate.label);
},
}),
];

export const SortControlled = () => {
const [sortState, setSortState] = React.useState<{
sortDirection: "ascending" | "descending";
sortColumn: TableColumnId | undefined;
}>({
sortDirection: "ascending" as const,
sortColumn: "file",
});

const {
getRows,
sort: { getSortDirection, toggleColumnSort, sort },
} = useTableFeatures(
{
columns,
items,
},
[
useTableSort({
sortState,
onSortChange: (e, nextSortState) => setSortState(nextSortState),
}),
]
);

const headerSortProps = (columnId: TableColumnId) => ({
onClick: (e: React.MouseEvent) => toggleColumnSort(e, columnId),
sortDirection: getSortDirection(columnId),
});

const rows = sort(getRows());

return (
<Table
sortable
aria-label="Table with controlled sort"
style={{ minWidth: "500px" }} >
<TableHeader>
<TableRow>
<TableHeaderCell {...headerSortProps("file")}>File</TableHeaderCell>
<TableHeaderCell {...headerSortProps("author")}>
Author
</TableHeaderCell>
<TableHeaderCell {...headerSortProps("lastUpdated")}>
Last updated
</TableHeaderCell>
<TableHeaderCell {...headerSortProps("lastUpdate")}>
Last update
</TableHeaderCell>
</TableRow>
</TableHeader>
<TableBody>
{rows.map(({ item }) => (
<TableRow key={item.file.label}>
<TableCell>
<TableCellLayout media={item.file.icon}>
{item.file.label}
</TableCellLayout>
</TableCell>
<TableCell>
<TableCellLayout
media={
<Avatar
aria-label={item.author.label}
name={item.author.label}
badge={{
                      status: item.author.status as PresenceBadgeStatus,
                    }}
/>
} >
{item.author.label}
</TableCellLayout>
</TableCell>
<TableCell>{item.lastUpdated.label}</TableCell>
<TableCell>
<TableCellLayout media={item.lastUpdate.icon}>
{item.lastUpdate.label}
</TableCellLayout>
</TableCell>
</TableRow>
))}
</TableBody>
</Table>
);
};

```

# Current file structure
chat-with-pdf-challenge
â”œâ”€â”€ README.md
â”œâ”€â”€ components.json
â”œâ”€â”€ firebase.ts
â”œâ”€â”€ firebaseAdmin.ts
â”œâ”€â”€ hooks
â”‚   â”œâ”€â”€ useSubscription.ts
â”‚   â””â”€â”€ useUpload.ts
â”œâ”€â”€ instruction
â”‚   â””â”€â”€ intructions.md
â”œâ”€â”€ next-env.d.ts
â”œâ”€â”€ next.config.mjs
â”œâ”€â”€ package-lock.json
â”œâ”€â”€ package.json
â”œâ”€â”€ postcss.config.mjs
â”œâ”€â”€ public
â”‚   â”œâ”€â”€ next.svg
â”‚   â””â”€â”€ vercel.svg
â”œâ”€â”€ service_key.json
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ actions
â”‚   â”‚   â”œâ”€â”€ askQuestion.ts
â”‚   â”‚   â”œâ”€â”€ classifyDocument.ts
â”‚   â”‚   â”œâ”€â”€ createCheckoutSession.ts
â”‚   â”‚   â”œâ”€â”€ createStripePortal.ts
â”‚   â”‚   â”œâ”€â”€ deleteDocument.ts
â”‚   â”‚   â””â”€â”€ generateEmbeddings.ts
â”‚   â”œâ”€â”€ app
â”‚   â”‚   â”œâ”€â”€ dashboard
â”‚   â”‚   â”‚   â”œâ”€â”€ files
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ [id]
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ page.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ layout.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ page.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ upgrade
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
â”‚   â”‚   â”‚   â””â”€â”€ upload
â”‚   â”‚   â”‚       â””â”€â”€ page.tsx
â”‚   â”‚   â”œâ”€â”€ favicon.ico
â”‚   â”‚   â”œâ”€â”€ globals.css
â”‚   â”‚   â”œâ”€â”€ layout.tsx
â”‚   â”‚   â”œâ”€â”€ page.tsx
â”‚   â”‚   â”œâ”€â”€ sign-in
â”‚   â”‚   â”‚   â””â”€â”€ [[...sign-in]]
â”‚   â”‚   â”‚       â””â”€â”€ page.tsx
â”‚   â”‚   â”œâ”€â”€ sign-up
â”‚   â”‚   â”‚   â””â”€â”€ [[...sign-up]]
â”‚   â”‚   â”‚       â””â”€â”€ page.tsx
â”‚   â”‚   â””â”€â”€ webhook
â”‚   â”‚       â””â”€â”€ route.ts
â”‚   â”œâ”€â”€ components
â”‚   â”‚   â”œâ”€â”€ Chat.tsx
â”‚   â”‚   â”œâ”€â”€ ChatMessage.tsx
â”‚   â”‚   â”œâ”€â”€ Document.tsx
â”‚   â”‚   â”œâ”€â”€ Documents.tsx
â”‚   â”‚   â”œâ”€â”€ FileUploader.tsx
â”‚   â”‚   â”œâ”€â”€ Header.tsx
â”‚   â”‚   â”œâ”€â”€ PdfView.tsx
â”‚   â”‚   â”œâ”€â”€ PlaceholderDocument.tsx
â”‚   â”‚   â”œâ”€â”€ UpgradeButton.tsx
â”‚   â”‚   â””â”€â”€ ui
â”‚   â”‚       â”œâ”€â”€ button.tsx
â”‚   â”‚       â”œâ”€â”€ input.tsx
â”‚   â”‚       â”œâ”€â”€ toast.tsx
â”‚   â”‚       â”œâ”€â”€ toaster.tsx
â”‚   â”‚       â””â”€â”€ use-toast.ts
â”‚   â”œâ”€â”€ lib
â”‚   â”‚   â”œâ”€â”€ azure-doc-intelligence.ts
â”‚   â”‚   â”œâ”€â”€ getBaseUrl.ts
â”‚   â”‚   â”œâ”€â”€ langchain.ts
â”‚   â”‚   â”œâ”€â”€ pinecone.ts
â”‚   â”‚   â”œâ”€â”€ stripe-js.ts
â”‚   â”‚   â”œâ”€â”€ stripe.ts
â”‚   â”‚   â”œâ”€â”€ test-classifier.ts
â”‚   â”‚   â””â”€â”€ utils.ts
â”‚   â””â”€â”€ middleware.ts
â”œâ”€â”€ table_instructions.md
â”œâ”€â”€ tailwind.config.ts
â””â”€â”€ tsconfig.json



# Additional requirements
1. Project setup
   - All new components should go in /components inside the src directory (not in the app folder) and be named like example-component.tsx unless otherwise specified
   - All new pages should go in /app
   - Use the Next.js 15 app router
   - All data fetching should be done in a server component and pass the data down as props
   - Client components (useState, hooks, etc) require that 'use client' is set at the top of the file

2. Server-Side API Calls:
   - All interactions with external APIs (e.g., Reddit, OpenAI, Microsoft Graph) should be performed server-side.
   - Create dedicated API routes in the `pages/api` directory for each external API interaction.
   - Client-side components should fetch data through these API routes, not directly from external APIs.
   - Server actions can also be used to make API calls from client-side components.

3. Environment Variables:
   - Store all sensitive information (API keys, credentials) in environment variables.
   - Use a `.env.local` file for local development and ensure it's listed in `.gitignore`.
   - For production, set environment variables in the deployment platform (e.g., Vercel).
   - Access environment variables only in server-side code or API routes.

4. Error Handling and Logging:
   - Implement comprehensive error handling in both client-side components and server-side API routes.
   - Log errors on the server-side for debugging purposes.
   - Display user-friendly error messages on the client-side.

5. Type Safety:
   - Use TypeScript interfaces for all data structures, especially API responses.
   - Avoid using `any` type; instead, define proper types for all variables and function parameters.

6. API Client Initialization:
   - Initialize API clients (e.g., Graph, OpenAI) in server-side code only.
   - Implement checks to ensure API clients are properly initialized before use.

7. Data Fetching in Components:
   - Use React hooks (e.g., `useEffect`) for data fetching in client-side components.
   - Implement loading states and error handling for all data fetching operations.

8. Next.js Configuration:
   - Utilize `next.config.mjs` for environment-specific configurations.
   - Use the `env` property in `next.config.mjs` to make environment variables available to the application.

9.  CORS and API Routes:
   - Use Next.js API routes to avoid CORS issues when interacting with external APIs.
   - Implement proper request validation in API routes.

10. Component Structure:
   - Separate concerns between client and server components.
   - Use server components for initial data fetching and pass data as props to client components.

11. Security:
    - Never expose API keys or sensitive credentials on the client-side.
    - Implement proper authentication and authorization for API routes if needed.
```
